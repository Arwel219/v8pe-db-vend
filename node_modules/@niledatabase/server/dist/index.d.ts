import pg, { PoolConfig, PoolClient } from 'pg';

type Routes = {
    SIGNIN: string;
    SESSION: string;
    PROVIDERS: string;
    CSRF: string;
    CALLBACK: string;
    SIGNOUT: string;
    ERROR: string;
    ME: string;
    USERS: string;
    TENANTS: string;
    TENANT: string;
    TENANT_USER: string;
    TENANT_USERS: string;
    SIGNUP: string;
    VERIFY_REQUEST: string;
    PASSWORD_RESET: string;
    LOG: string;
};

type ApiParams = {
    basePath?: string | undefined;
    cookieKey?: string;
    token?: string | undefined;
    callbackUrl?: string | undefined;
    routes?: Partial<Routes>;
    routePrefix?: string | undefined;
    secureCookies?: boolean;
    origin?: null | undefined | string;
    headers?: null | Headers | Record<string, string>;
};
declare class ApiConfig {
    #private;
    cookieKey?: string;
    basePath?: string | undefined;
    routes?: Partial<Routes>;
    routePrefix?: string;
    secureCookies?: boolean;
    origin?: string | null;
    headers?: Headers | null;
    /**
     * The client side callback url. Defaults to nothing (so nile.origin will be it), but in the cases of x-origin, you want to set this explicitly to be sure nile-auth does the right thing
     * If this is set, any `callbackUrl` from the client will be ignored.
     */
    callbackUrl?: string;
    constructor(config?: ServerConfig, logger?: string);
    get token(): string | undefined;
    set token(value: string | undefined);
}
declare class Config {
    #private;
    user: string;
    password: string;
    databaseId: string;
    databaseName: string;
    logger?: LoggerType;
    debug: boolean;
    db: NilePoolConfig;
    api: ApiConfig;
    get tenantId(): string | undefined | null;
    set tenantId(value: string | undefined | null);
    get userId(): string | undefined | null;
    set userId(value: string | undefined | null);
    constructor(config?: ServerConfig, logger?: string);
    configure: (config: ServerConfig) => Promise<Config>;
}

type Opts = {
    basePath?: string;
    fetch?: typeof fetch;
};
type NilePoolConfig = PoolConfig & {
    afterCreate?: AfterCreate;
};
type LoggerType = {
    info?: (args: unknown | unknown[]) => void;
    warn?: (args: unknown | unknown[]) => void;
    error?: (args: unknown | unknown[]) => void;
    debug?: (args: unknown | unknown[]) => void;
};
type ServerConfig = {
    databaseId?: string;
    user?: string;
    password?: string;
    databaseName?: string;
    tenantId?: string | null | undefined;
    userId?: string | null | undefined;
    debug?: boolean;
    configureUrl?: string;
    db?: NilePoolConfig;
    api?: ApiParams;
    logger?: LoggerType;
};
type NileDb = NilePoolConfig & {
    tenantId?: string;
};
type AfterCreate = (conn: PoolClient, done: (err: null | Error, conn: PoolClient) => void) => void;
type Database = {
    name: string;
    apiHost: string;
    dbHost: string;
    id: string;
    message?: string;
    status: 'READY' | string;
};

interface CreateBasicUserRequest {
    email: string;
    password: string;
    name?: string;
    familyName?: string;
    givenName?: string;
    picture?: string;
    newTenantName?: string;
    tenantId?: string;
}
interface CreateTenantUserRequest {
    email: string;
    password: string;
    name?: string;
    familyName?: string;
    givenName?: string;
    picture?: string;
}
declare const LoginUserResponseTokenTypeEnum: {
    readonly AccessToken: "ACCESS_TOKEN";
    readonly RefreshToken: "REFRESH_TOKEN";
    readonly IdToken: "ID_TOKEN";
};
type LoginUserResponseTokenTypeEnum = (typeof LoginUserResponseTokenTypeEnum)[keyof typeof LoginUserResponseTokenTypeEnum];
interface LoginUserResponseToken {
    jwt: string;
    maxAge: number;
    type: LoginUserResponseTokenTypeEnum;
}
interface LoginUserResponse {
    [key: string]: any;
    id: string;
    token: LoginUserResponseToken;
}
interface User {
    id: string;
    email: string;
    name?: string | null;
    familyName?: string | null;
    givenName?: string | null;
    picture?: string | null;
    created: string;
    updated?: string;
    emailVerified?: string | null;
    tenants: {
        id: string;
    }[];
}

type Tenant = {
    id: string;
    name: string;
};

type Provider = {
    id: string;
    name: string;
    type: string;
    signinUrl: string;
    callbackUr: string;
};
type JWT = {
    email: string;
    sub: string;
    id: string;
    iat: number;
    exp: number;
    jti: string;
};
type ActiveSession = {
    id: string;
    email: string;
    expires: string;
    user?: {
        id: string;
        name: string;
        image: string;
        email: string;
        emailVerified: void | Date;
    };
};

interface NileBody<R, B> {
    readonly body: ReadableStream<Uint8Array> | null | B;
    readonly bodyUsed: boolean;
    arrayBuffer(): Promise<ArrayBuffer>;
    blob(): Promise<Blob>;
    formData(): Promise<FormData>;
    json(): Promise<R>;
    text(): Promise<string>;
}
interface NRequest<T> extends NileBody<any, T> {
    /** Returns the cache mode associated with request, which is a string indicating how the request will interact with the browser's cache when fetching. */
    readonly cache: RequestCache;
    /** Returns the credentials mode associated with request, which is a string indicating whether credentials will be sent with the request always, never, or only when sent to a same-origin URL. */
    readonly credentials: RequestCredentials;
    /** Returns the kind of resource requested by request, e.g., "document" or "script". */
    readonly destination: RequestDestination;
    /** Returns a Headers object consisting of the headers associated with request. Note that headers added in the network layer by the user agent will not be accounted for in this object, e.g., the "Host" header. */
    readonly headers: Headers;
    /** Returns request's subresource integrity metadata, which is a cryptographic hash of the resource being fetched. Its value consists of multiple hashes separated by whitespace. [SRI] */
    readonly integrity: string;
    /** Returns a boolean indicating whether or not request can outlive the global in which it was created. */
    readonly keepalive: boolean;
    /** Returns request's HTTP method, which is "GET" by default. */
    readonly method: string;
    /** Returns the mode associated with request, which is a string indicating whether the request will use CORS, or will be restricted to same-origin URLs. */
    readonly mode: RequestMode;
    /** Returns the redirect mode associated with request, which is a string indicating how redirects for the request will be handled during fetching. A request will follow redirects by default. */
    readonly redirect: RequestRedirect;
    /** Returns the referrer of request. Its value can be a same-origin URL if explicitly set in init, the empty string to indicate no referrer, and "about:client" when defaulting to the global's default. This is used during fetching to determine the value of the `Referer` header of the request being made. */
    readonly referrer: string;
    /** Returns the referrer policy associated with request. This is used during fetching to compute the value of the request's referrer. */
    readonly referrerPolicy: ReferrerPolicy;
    /** Returns the signal associated with request, which is an AbortSignal object indicating whether or not request has been aborted, and its abort event handler. */
    readonly signal: AbortSignal;
    /** Returns the URL of request as a string. */
    readonly url: string;
    clone(): Request;
}
type NileRequest<T> = NRequest<T> | T;

declare class Auth extends Config {
    headers?: Headers;
    resetHeaders?: (headers?: Headers) => void;
    constructor(config: Config, headers?: Headers, params?: {
        resetHeaders: () => void;
    });
    handleHeaders(init?: RequestInit): RequestInit | undefined;
    get sessionUrl(): string;
    getSession: <T = JWT | ActiveSession | Response | undefined>(req: NileRequest<void> | Headers, init?: RequestInit) => Promise<T>;
    get getCsrfUrl(): string;
    getCsrf<T = Response | JSON>(req: NileRequest<void> | Headers, init?: RequestInit, raw?: boolean): Promise<T>;
    get listProvidersUrl(): string;
    listProviders: <T = Response | {
        [key: string]: Provider;
    }>(req: NileRequest<void> | Headers, init?: RequestInit) => Promise<T>;
    get signOutUrl(): string;
    signOut: <T = Response | {
        url: string;
    }>(req: NileRequest<void | {
        callbackUrl?: string;
    }> | Headers, init?: RequestInit) => Promise<T>;
}

declare class Tenants extends Config {
    headers?: Headers;
    constructor(config: Config, headers?: Headers);
    handleHeaders(init?: RequestInit): RequestInit | undefined;
    get tenantsUrl(): string;
    get tenantUrl(): string;
    createTenant: <T = Tenant | Response>(req: NileRequest<{
        name: string;
        id?: string;
    }> | Headers | string, init?: RequestInit) => Promise<T>;
    getTenant: <T = Tenant | Response>(req: NileRequest<{
        id: string;
    }> | Headers | string | void, init?: RequestInit) => Promise<T>;
    get tenantListUrl(): string;
    listTenants: <T = Tenant[] | Response>(req: NileRequest<void> | Headers, init?: RequestInit) => Promise<T>;
    deleteTenant: <T = Response>(req: NileRequest<void> | Headers | string, init?: RequestInit) => Promise<T>;
    updateTenant: <T = Tenant | Response>(req: NileRequest<void> | Headers | {
        name: string;
    }, init?: RequestInit) => Promise<T>;
}

declare class Users extends Config {
    headers?: Headers;
    constructor(config: Config, headers?: Headers);
    usersUrl(user: CreateBasicUserRequest): string;
    get tenantUsersUrl(): string;
    get linkUsersUrl(): string;
    get tenantUserUrl(): string;
    handleHeaders(init?: RequestInit): RequestInit | undefined;
    createUser: <T = User | Response>(user: CreateBasicUserRequest, init?: RequestInit) => Promise<T>;
    createTenantUser: <T = User | Response>(req: NileRequest<CreateTenantUserRequest>, init?: RequestInit) => Promise<T>;
    updateUser: <T = User[] | Response>(req: NileRequest<Partial<Omit<User, "email" | "tenants" | "created" | "updated">>>, init?: RequestInit) => Promise<T>;
    listUsers: <T = User[] | Response>(req: NileRequest<void> | Headers, init?: RequestInit) => Promise<T>;
    linkUser: <T = User | Response>(req: NileRequest<{
        id: string;
        tenantId?: string;
    }> | Headers | string, init?: RequestInit) => Promise<T>;
    unlinkUser: <T = Response>(req: NileRequest<{
        id: string;
        tenantId?: string;
    }> | Headers | string, init?: RequestInit) => Promise<T>;
    get meUrl(): string;
    me: <T = User | Response>(req: NileRequest<void> | Headers, init?: RequestInit) => Promise<T>;
    updateMe: <T = User | Response>(req: NileRequest<Partial<Omit<User, "email" | "id" | "tenants" | "created" | "updated">>> | Headers, init?: RequestInit) => Promise<T>;
}

declare class Api {
    #private;
    config: Config;
    users: Users;
    auth: Auth;
    tenants: Tenants;
    routes: Routes;
    handlers: {
        GET: (req: Request) => Promise<void | Response>;
        POST: (req: Request) => Promise<void | Response>;
        DELETE: (req: Request) => Promise<void | Response>;
        PUT: (req: Request) => Promise<void | Response>;
    };
    handlersWithContext: {
        GET: (req: Request) => Promise<{
            response: void | Response;
            nile: Server;
        }>;
        POST: (req: Request) => Promise<{
            response: void | Response;
            nile: Server;
        }>;
        DELETE: (req: Request) => Promise<{
            response: void | Response;
            nile: Server;
        }>;
        PUT: (req: Request) => Promise<{
            response: void | Response;
            nile: Server;
        }>;
    };
    paths: {
        get: string[];
        post: string[];
        delete: string[];
        put: string[];
    };
    constructor(config: Config);
    reset: () => void;
    updateConfig: (config: Config) => void;
    resetHeaders: (headers?: Headers) => void;
    /**
     * Merge headers together
     */
    set headers(headers: Headers | Record<string, string>);
    get headers(): Headers | undefined;
    getCookie(req?: Request | Headers): string | null | undefined;
    login: (payload: {
        email: string;
        password: string;
    }, config?: {
        returnResponse?: boolean;
    }) => Promise<Response | undefined>;
    session: (req?: Request | Headers | null | undefined) => Promise<Response | JWT | ActiveSession | null | undefined>;
    setContext: (req: Request | Headers | Record<string, string> | unknown) => void;
}

declare class Server {
    config: Config;
    api: Api;
    private manager;
    constructor(config?: ServerConfig);
    setConfig(cfg: Config): void;
    init(cfg?: Config): Promise<this>;
    set databaseId(val: string | void);
    get userId(): string | undefined | null;
    set userId(userId: string | undefined | null);
    get tenantId(): string | undefined | null;
    set tenantId(tenantId: string | undefined | null);
    get token(): string | undefined | null;
    set token(token: string | undefined | null);
    get db(): pg.Pool;
    clearConnections(): void;
    /**
     * A convenience function that applies a config and ensures whatever was passed is set properly
     */
    getInstance<T = Request | Headers | Record<string, string>>(config: ServerConfig, req?: T): Server;
}
declare function create(config?: ServerConfig): Promise<Server>;

export { type ActiveSession, type AfterCreate, type CreateBasicUserRequest, type CreateTenantUserRequest, type Database, type JWT, type LoggerType, type LoginUserResponse, type LoginUserResponseToken, LoginUserResponseTokenTypeEnum, create as Nile, type NileDb, type NilePoolConfig, type Opts, Server, type ServerConfig, type Tenant, type User };
