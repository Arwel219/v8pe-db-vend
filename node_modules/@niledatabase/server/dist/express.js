'use strict';

// src/utils/Logger.ts
var red = "\x1B[31m";
var yellow = "\x1B[38;2;255;255;0m";
var purple = "\x1B[38;2;200;160;255m";
var orange = "\x1B[38;2;255;165;0m";
var reset = "\x1B[0m";
var baseLogger = (config, ...params) => ({
  info(message, meta) {
    if (config?.debug) {
      console.info(
        `${orange}[niledb]${reset}${purple}[DEBUG]${reset}${params.join(
          ""
        )}${reset} ${message}`,
        meta ? `${JSON.stringify(meta)}` : ""
      );
    }
  },
  debug(message, meta) {
    if (config?.debug) {
      console.debug(
        `${orange}[niledb]${reset}${purple}[DEBUG]${reset}${params.join(
          ""
        )}${reset} ${message}`,
        meta ? `${JSON.stringify(meta)}` : ""
      );
    }
  },
  warn(message, meta) {
    if (config?.debug) {
      console.warn(
        `${orange}[niledb]${reset}${yellow}[WARN]${reset}${params.join(
          ""
        )}${reset} ${message}`,
        meta ? JSON.stringify(meta) : ""
      );
    }
  },
  error(message, meta) {
    console.error(
      `${orange}[niledb]${reset}${red}[ERROR]${reset}${params.join(
        ""
      )}${red} ${message}`,
      meta ? meta : "",
      `${reset}`
    );
  }
});
function Logger(config, ...params) {
  const base = baseLogger(config, params);
  const info = config?.logger?.info ?? base.info;
  const debug = config?.logger?.debug ?? base.debug;
  const warn = config?.logger?.warn ?? base.warn;
  const error = config?.logger?.error ?? base.error;
  return { info, warn, error, debug };
}

// src/lib/express.ts
function cleaner(val) {
  return val.replaceAll(/\{([^}]+)\}/g, ":$1");
}
function expressPaths(nile) {
  const paths = {
    get: nile.api.paths.get.map(cleaner),
    post: nile.api.paths.post.map(cleaner),
    put: nile.api.paths.put.map(cleaner),
    delete: nile.api.paths.delete.map(cleaner)
  };
  return {
    paths
  };
}
async function NileExpressHandler(nile, config) {
  const { error } = Logger(nile.config, "nile-express");
  async function handler(req, res) {
    const headers = new Headers();
    if (!req || typeof req !== "object") {
      return null;
    }
    if (!("url" in req) || typeof req?.url !== "string") {
      error("A url is necessary for the nile express handler");
      return null;
    }
    const method = "method" in req && typeof req.method === "string" ? req.method : "GET";
    if ("headers" in req && typeof req.headers === "object" && req.headers && "cookie" in req.headers && typeof req.headers.cookie === "string") {
      headers.set("cookie", req.headers.cookie);
    }
    const _init = { method, ...config?.init };
    if ("body" in req) {
      if (method === "POST" || method === "PUT") {
        headers.set("content-type", "application/json");
        _init.body = JSON.stringify(req.body);
      }
    }
    _init.headers = headers;
    const reqUrl = req.protocol + "://" + req.get("host") + req.originalUrl;
    try {
      new URL(reqUrl);
    } catch (e) {
      error("Invalid URL", {
        url: reqUrl,
        error: e
      });
      return null;
    }
    const proxyRequest = new Request(reqUrl, _init);
    let response;
    try {
      response = await nile.api.handlers[method](proxyRequest);
    } catch (e) {
      error(e);
    }
    let body;
    if (response instanceof Response) {
      try {
        const tryJson = await response.clone();
        body = await tryJson.json();
      } catch (e) {
        body = await response.text();
      }
      const newHeaders = {};
      response.headers.forEach((value, key) => {
        if (!["content-length", "transfer-encoding"].includes(key.toLowerCase())) {
          if (newHeaders[key]) {
            const prev = newHeaders[key];
            if (Array.isArray(prev)) {
              newHeaders[key] = [...prev, value];
            } else {
              newHeaders[key] = [prev, value];
            }
          } else {
            newHeaders[key] = value;
          }
        }
      });
      if (config?.muteResponse !== true) {
        if (res) {
          res.status(response.status).set(newHeaders);
          if (typeof body === "string") {
            res.send(body);
          } else {
            res.json(body ?? {});
          }
        }
        return;
      }
      return {
        body,
        status: response.status,
        headers: newHeaders,
        response
      };
    } else {
      error("Bad response", { response });
      return;
    }
  }
  const { paths } = expressPaths(nile);
  return { handler, paths };
}

exports.NileExpressHandler = NileExpressHandler;
exports.cleaner = cleaner;
exports.expressPaths = expressPaths;
//# sourceMappingURL=express.js.map
//# sourceMappingURL=express.js.map