import * as React$1 from 'react';
import React__default from 'react';
import * as _tanstack_react_query from '@tanstack/react-query';
import { QueryClient } from '@tanstack/react-query';
import { IncomingMessage } from 'http';
import * as class_variance_authority_dist_types from 'class-variance-authority/dist/types';
import { VariantProps } from 'class-variance-authority';

interface SignInResponse$1 {
    error: string | null;
    status: number;
    ok: boolean;
    url: string | null;
}
type LiteralUnion<T extends U, U = string> = T | (U & Record<never, never>);
interface SignInOptions extends Record<string, unknown> {
    /**
     * Specify to which URL the user will be redirected after signing in. Defaults to the page URL the sign-in is initiated from.
     *
     * [Documentation](https://next-auth.js.org/getting-started/client#specifying-a-callbackurl)
     */
    callbackUrl?: string;
    /** [Documentation](https://next-auth.js.org/getting-started/client#using-the-redirect-false-option) */
    redirect?: boolean;
}
type SignInAuthorizationParams = string | string[][] | Record<string, string> | URLSearchParams;
type ProviderType = 'oauth' | 'email' | 'credentials';
interface ClientSafeProvider {
    id: LiteralUnion<BuiltInProviderType>;
    name: string;
    type: ProviderType;
    signinUrl: string;
    callbackUrl: string;
}
type RedirectableProviderType = 'email' | 'credentials';
type OAuthProviderType = 'linkedin' | 'hubspot' | 'google' | 'azure-ad' | 'slack' | 'github' | 'twitter' | 'discord';
type BuiltInProviderType = RedirectableProviderType | OAuthProviderType;
type JWT = {
    email: string;
    sub: string;
    id: string;
    iat: number;
    exp: number;
    jti: string;
    loading: boolean;
};
type ActiveSession = {
    loading: boolean;
    id: string;
    email: string;
    expires: string;
    user?: {
        id: string;
        name: string;
        image: string;
        email: string;
        emailVerified: void | Date;
    };
};
type NonErrorSession = JWT | ActiveSession | null | undefined;
type NileSession = Response | NonErrorSession;
type AuthState = {
    basePath: string;
    baseUrl: string;
    lastSync: number;
    getSession: (...args: any[]) => void;
    session: NonErrorSession | undefined | null;
    loading: boolean;
};
type ListenerParams = {
    key: ListenerKeys;
    next: any;
    prev: any;
};
type Listener = (callback: ListenerParams) => void;
type ListenerKeys = 'basePath' | 'baseUrl' | 'lastSync' | 'getSession' | 'session' | 'loading';
type AuthConfig = Config & {
    listenerKeys?: Array<ListenerKeys>;
};
type Config = {
    basePath?: string;
    baseUrl?: string;
    init?: RequestInit;
};
type PartialAuthorizer = null | {
    state?: {
        baseUrl?: string;
        basePath?: string;
        session?: {
            user?: {
                email?: string | undefined;
            };
        };
    };
    requestInit?: RequestInit | undefined;
};
interface CtxOrReq {
    req?: Partial<IncomingMessage> & {
        body?: any;
    };
    ctx?: {
        req: Partial<IncomingMessage> & {
            body?: any;
        };
    };
}
interface SignOutParams<R extends boolean = true> {
    callbackUrl?: string;
    redirect?: R;
}
interface SignOutResponse {
    url: string;
}

type EmailSignInInfo = SignInOptions;
type SignInSuccess = (response: Response) => void;
type AllowedAny$3 = any;
type Props$5 = {
    redirect?: boolean;
    onSuccess?: SignInSuccess;
    onError?: (e: Error, info: EmailSignInInfo) => void;
    beforeMutate?: (data: AllowedAny$3) => AllowedAny$3;
    buttonText?: string;
    client?: QueryClient;
    callbackUrl?: string;
    init?: RequestInit;
};

declare function EmailSigningIn(props: Props$5): React__default.JSX.Element;

declare const buttonVariants: (props?: ({
    variant?: "default" | "link" | "destructive" | "outline" | "secondary" | "ghost" | null | undefined;
    size?: "default" | "sm" | "lg" | "icon" | null | undefined;
} & class_variance_authority_dist_types.ClassProp) | undefined) => string;
interface ButtonProps extends React$1.ButtonHTMLAttributes<HTMLButtonElement>, VariantProps<typeof buttonVariants> {
    asChild?: boolean;
    loading?: boolean;
}

type WarningCode = 'NEXTAUTH_URL' | 'NO_SECRET' | 'TWITTER_OAUTH_2_BETA' | 'DEBUG_ENABLED';
/**
 * Override any of the methods, and the rest will use the default logger.
 *
 * [Documentation](https://next-auth.js.org/configuration/options#logger)
 */
interface LoggerInstance extends Record<string, (...args: any) => any> {
    warn: (code: WarningCode) => void;
    error: (code: string, 
    /**
     * Either an instance of (JSON serializable) Error
     * or an object that contains some debug information.
     * (Error is still available through `metadata.error`)
     */
    metadata: Error | {
        error: Error;
        [key: string]: unknown;
    }) => void;
    debug: (code: string, metadata: unknown) => void;
}

type GetSessionParams = CtxOrReq & {
    event?: 'storage' | 'timer' | 'hidden' | string;
    triggerEvent?: boolean;
    broadcast?: boolean;
    baseUrl?: string;
    init?: RequestInit;
};
declare enum State {
    SESSION = "getSession"
}
declare class Authorizer {
    state: AuthState;
    logger: LoggerInstance;
    requestInit?: RequestInit;
    addListener: (cb: Listener) => void;
    removeListener: (cb: Listener) => void;
    status: null | State;
    constructor(config?: AuthConfig);
    sync(event?: 'storage' | 'timer' | 'hidden' | 'poll' | 'visibilitychange'): Promise<void>;
    set baseUrl(val: string);
    get baseUrl(): string;
    configure(config?: Config): this;
    sanitize(): PartialAuthorizer;
    initialize(params?: {
        baseUrl?: string;
        session?: NonErrorSession | null | undefined;
        event?: 'storage' | 'timer' | 'hidden' | 'poll' | 'visibilitychange';
    }): Promise<void>;
    get apiBaseUrl(): string;
    fetchData<T = Record<string, string>>(url: string, init?: RequestInit): Promise<T | undefined>;
    fetchFormData<T = {
        url: string;
    }>(url: string, init: RequestInit): Promise<{
        data: T;
        status: number;
        ok: boolean;
        url: string;
    } | undefined>;
    getProviders(): Promise<Record<LiteralUnion<BuiltInProviderType>, ClientSafeProvider> | undefined>;
    getCsrfToken(): Promise<string | undefined>;
    getSession(params?: GetSessionParams): Promise<NonErrorSession>;
    refreshSession(): Promise<NonErrorSession>;
    signOut<R extends boolean = true>(options?: SignOutParams<R> & {
        baseUrl?: string;
        auth?: Authorizer | PartialAuthorizer;
        fetchUrl?: string;
        basePath?: string;
    }): Promise<R extends true ? undefined : SignOutResponse>;
    signIn<P extends RedirectableProviderType | undefined = undefined>(provider?: LiteralUnion<P extends RedirectableProviderType ? P | BuiltInProviderType : BuiltInProviderType>, options?: SignInOptions & {
        baseUrl?: string;
        init?: ResponseInit;
        fetchUrl?: string;
        auth?: Authorizer | PartialAuthorizer;
    }, authorizationParams?: SignInAuthorizationParams): Promise<P extends RedirectableProviderType ? SignInResponse$1 | undefined : undefined>;
    signUp(options: {
        baseUrl?: string;
        init?: ResponseInit;
        fetchUrl?: string;
        newTenantName?: string;
        createTenant?: string | boolean;
        email: string;
        password: string;
        auth?: Authorizer | PartialAuthorizer;
        tenantId?: string;
        callbackUrl?: string;
        redirect?: boolean;
    }): Promise<any>;
}
declare const authorizer: Authorizer;
declare const auth: Authorizer;
declare const getSession: (params?: GetSessionParams) => Promise<NonErrorSession>;
declare const getCsrfToken: () => Promise<string | undefined>;
declare const getProviders: () => Promise<Record<LiteralUnion<BuiltInProviderType>, ClientSafeProvider> | undefined>;
declare const signOut: typeof authorizer.signOut;
declare const signIn: typeof authorizer.signIn;

interface SignInResponse {
    error: string | null;
    status: number;
    ok: boolean;
    url: string | null;
}
type SSOButtonProps = {
    callbackUrl?: string;
    buttonText?: string;
    init?: RequestInit;
    baseUrl?: string;
    fetchUrl?: string;
    auth?: Authorizer | PartialAuthorizer;
    onClick?: (e: React.MouseEvent<HTMLButtonElement, MouseEvent>, res: SignInResponse | undefined) => void;
};

type EmailError = void | {
    error: string;
    ok: boolean;
    status: number;
    url: null | string;
};
type AllProps = ButtonProps & SSOButtonProps & {
    callbackUrl?: string;
    redirect?: boolean;
    email: string;
    onSent?: () => void;
    onFailure?: (error: EmailError) => void;
    buttonText?: string;
};
/**
 * This works when the email identity provider is configured in the admin dashboard.
 * @param props callbackUrl: the url to send the user to from their email
 * @param props redirect: redirect to the default (unbranded) 'check your email' page. default is false
 * @param props email:  the email to send to
 * @param props onSent:  called if the email was sent
 * @param props onFailure:  called if there was a reportable
 * @returns a JSX.Element to render
 */
declare const EmailSignInButton: {
    ({ callbackUrl, className, variant, size, asChild, redirect, buttonText, email, onFailure, onSent, fetchUrl, baseUrl, auth, ...props }: AllProps): React__default.JSX.Element;
    displayName: string;
};

declare function useEmailSignIn(params?: Props$5): _tanstack_react_query.UseMutateFunction<Response, Error, SignInOptions, unknown>;

/**
 * A component for a Google login button, according to their design language.
 * This works when an identity provider is configured in the admin dashboard.
 * @param props callbackUrl: a string to override the URL provided by the context
 * @returns a JSX.Element to render
 */
declare const GoogleSSOButton: {
    ({ callbackUrl, className, variant, size, buttonText, asChild, init, auth, fetchUrl, baseUrl, ...props }: ButtonProps & SSOButtonProps): React__default.JSX.Element;
    displayName: string;
};

declare const AzureSignInButton: {
    ({ callbackUrl, className, buttonText, variant, size, init, asChild, auth, fetchUrl, baseUrl, ...props }: ButtonProps & SSOButtonProps): React__default.JSX.Element;
    displayName: string;
};

declare const DiscordSignInButton: {
    ({ callbackUrl, className, buttonText, variant, size, asChild, init, auth, fetchUrl, baseUrl, ...props }: ButtonProps & SSOButtonProps): React__default.JSX.Element;
    displayName: string;
};

declare const GitHubSignInButton: {
    ({ callbackUrl, className, buttonText, variant, size, init, asChild, auth, fetchUrl, baseUrl, ...props }: ButtonProps & SSOButtonProps): React__default.JSX.Element;
    displayName: string;
};

declare const HubSpotSignInButton: {
    ({ callbackUrl, className, buttonText, variant, size, init, asChild, auth, fetchUrl, baseUrl, ...props }: ButtonProps & SSOButtonProps): React__default.JSX.Element;
    displayName: string;
};

declare const LinkedInSignInButton: {
    ({ callbackUrl, className, buttonText, variant, size, asChild, init, auth, fetchUrl, baseUrl, ...props }: ButtonProps & SSOButtonProps): React__default.JSX.Element;
    displayName: string;
};

declare const SlackSignInButton: {
    ({ callbackUrl, className, buttonText, variant, size, init, asChild, ...props }: ButtonProps & {
        callbackUrl?: string;
        buttonText?: string;
        init?: RequestInit;
    }): React__default.JSX.Element;
    displayName: string;
};

declare const XSignInButton: {
    ({ callbackUrl, className, buttonText, variant, size, init, asChild, auth, fetchUrl, baseUrl, ...props }: ButtonProps & SSOButtonProps): React__default.JSX.Element;
    displayName: string;
};

type ComponentFetchProps = {
    auth?: Authorizer | PartialAuthorizer;
    init?: RequestInit;
    baseUrl?: string;
    basePath?: string;
};
type PrefetchParams = {
    baseUrl?: string;
    disableQuery?: boolean;
    init?: RequestInit;
    client?: QueryClient;
    fetchUrl?: string;
};

type SignUpInfo = {
    email: string;
    password: string;
    tenantId?: string;
    fetchUrl?: string;
    callbackUrl?: string;
    newTenantName?: string;
};
type AllowedAny$2 = any;
type Props$4 = PrefetchParams & {
    onSuccess?: (response: Response, formValues: SignUpInfo) => void;
    onError?: (e: Error, info: SignUpInfo) => void;
    beforeMutate?: (data: AllowedAny$2) => AllowedAny$2;
    buttonText?: string;
    callbackUrl?: string;
    createTenant?: string | boolean;
    className?: string;
    redirect?: boolean;
};

declare function SigningUp({ className, ...props }: Props$4): React__default.JSX.Element;

declare function useSignUp<T extends SignUpInfo>(params: Props$4, client?: QueryClient): _tanstack_react_query.UseMutateFunction<Response, Error, SignUpInfo, unknown>;

type AllowedAny$1 = any;
type LoginInfo = {
    email: string;
    password: string;
};
type LoginSuccess = (response: AllowedAny$1, formValues: LoginInfo, ...args: AllowedAny$1) => void;
type Props$3 = ComponentFetchProps & {
    beforeMutate?: (data: AllowedAny$1) => AllowedAny$1;
    onSuccess?: LoginSuccess;
    onError?: (error: Error, data: AllowedAny$1) => void;
    callbackUrl?: string;
    client?: QueryClient;
    className?: string;
    baseUrl?: string;
    fetchUrl?: string;
    redirect?: boolean;
};

declare function SigningIn({ className, ...props }: Props$3): React__default.JSX.Element;

declare function useSignIn(params?: Props$3): _tanstack_react_query.UseMutateFunction<SignInResponse$1 | undefined, Error, LoginInfo, any>;

type Props$2 = ButtonProps & ComponentFetchProps & {
    redirect?: boolean;
    callbackUrl?: string;
    buttonText?: string;
    baseUrl?: string;
    fetchUrl?: string;
    basePath?: string;
};
declare const SignOutButton: {
    ({ callbackUrl, redirect, className, buttonText, variant, size, baseUrl, fetchUrl, basePath, auth, asChild, ...props }: Props$2): React__default.JSX.Element;
    displayName: string;
};

interface SessionProviderProps {
    children: React__default.ReactNode;
    session?: NileSession;
    baseUrl?: string;
    basePath?: string;
    /**
     * A time interval (in seconds) after which the session will be re-fetched.
     * If set to `0` (default), the session is not polled.
     */
    refetchInterval?: number;
    /**
     * `SessionProvider` automatically refetches the session when the user switches between windows.
     * This option activates this behaviour if set to `true` (default).
     */
    refetchOnWindowFocus?: boolean;
    /**
     * Set to `false` to stop polling when the device has no internet access offline (determined by `navigator.onLine`)
     *
     * [`navigator.onLine` documentation](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorOnLine/onLine)
     */
    refetchWhenOffline?: false;
}
type UpdateSession = (data?: any) => Promise<NonErrorSession | null | undefined>;
type SessionContextValue<R extends boolean = false> = R extends true ? {
    update: UpdateSession;
    data: NonErrorSession;
    status: 'authenticated';
} | {
    update: UpdateSession;
    data: null | undefined;
    status: 'loading';
} : {
    update: UpdateSession;
    data: NonErrorSession;
    status: 'authenticated';
} | {
    update: UpdateSession;
    data: null | undefined;
    status: 'unauthenticated' | 'loading';
};
declare const SessionContext: React__default.Context<{
    update: UpdateSession;
    data: NonErrorSession;
    status: "authenticated";
} | {
    update: UpdateSession;
    data: null | undefined;
    status: "unauthenticated" | "loading";
} | undefined>;
interface UseSessionOptions<R extends boolean> {
    required: R;
    /** Defaults to `signIn` */
    onUnauthenticated?: () => void;
}
/**
 * React Hook that gives you access
 * to the logged in user's session data.
 *
 * [Documentation](https://next-auth.js.org/getting-started/client#usesession)
 */
declare function useSession<R extends boolean>(options?: UseSessionOptions<R>): SessionContextValue<R>;
/**
 * Signs the user out, by removing the session cookie.
 * Automatically adds the CSRF token to the request.
 *
 * [Documentation](https://next-auth.js.org/getting-started/client#signout)
 */
/**
 * Provider to wrap the app in to make session data available globally.
 * Can also be used to throttle the number of requests to the endpoint
 * `/api/auth/session`.
 *
 * [Documentation](https://next-auth.js.org/getting-started/client#sessionprovider)
 */
declare function SessionProvider(props: SessionProviderProps): React__default.JSX.Element;

declare function SignedIn({ children, session: startSession, ...props }: SessionProviderProps & {
    className?: string;
}): React__default.JSX.Element | null;

declare function SignedOut({ children, session: startSession, ...props }: SessionProviderProps & {
    className?: string;
}): React__default.JSX.Element | null;

type Tenant = {
    id: string;
    name: string;
};

type HookProps$1 = ComponentFetchProps & {
    fetchUrl?: string;
    tenants?: Tenant[];
    onError?: (e: Error) => void;
};
type ComponentProps = HookProps$1 & {
    client?: QueryClient;
    activeTenant?: string;
    useCookie?: boolean;
    className?: string;
    emptyText?: string;
    buttonText?: string;
};

declare function useTenants(params: HookProps$1 & {
    disableQuery?: boolean;
}, client?: QueryClient): _tanstack_react_query.UseQueryResult<Tenant[], Error>;
declare function useTenantId(params?: HookProps$1 & {
    tenant?: Tenant;
}, client?: QueryClient): [string | undefined, (tenant: string) => void];

declare function TenantSelector(props: ComponentProps): React__default.JSX.Element;

interface User {
    id: string;
    email: string;
    name?: string | null;
    familyName?: string | null;
    givenName?: string | null;
    picture?: string | null;
    created: string;
    updated?: string;
    emailVerified?: string | null;
    tenants: {
        id: string;
    }[];
}

type HookProps = ComponentFetchProps & {
    user?: User | undefined | null;
    baseUrl?: string;
    client?: QueryClient;
    fetchUrl?: string;
};
declare function useMe(props: HookProps): User | null;

type Props$1 = HookProps & {
    profilePicturePlaceholder?: React__default.ReactElement;
    className?: string;
};
declare function UserInfo(props: Props$1): React__default.JSX.Element;

type AllowedAny = any;
type Params = PrefetchParams & {
    beforeMutate?: (data: AllowedAny) => AllowedAny;
    onSuccess?: (res: Response) => void;
    onError?: (error: Error, data: AllowedAny) => void;
    callbackUrl?: string;
    basePath?: string;
};
type MutateFnParams = {
    email?: string;
    password?: string;
};
type Props = Params & {
    defaultValues?: MutateFnParams & {
        confirmPassword?: string;
    };
};

declare function ResetPasswordForm$1(props: Props): React__default.JSX.Element;

declare function ResetPasswordForm(params: Params): React__default.JSX.Element;

declare function useResetPassword(params?: Params): _tanstack_react_query.UseMutateFunction<Response, Error, MutateFnParams, unknown>;

declare const Email: () => React$1.JSX.Element;
declare const Password: () => React$1.JSX.Element;

export { type ActiveSession, type AuthConfig, type AuthState, Authorizer, AzureSignInButton as Azure, DiscordSignInButton as Discord, Email, EmailSigningIn as EmailSignIn, EmailSignInButton, GitHubSignInButton as GitHub, GoogleSSOButton as Google, HubSpotSignInButton as HubSpot, type JWT, LinkedInSignInButton as LinkedIn, type Listener, type ListenerKeys, type ListenerParams, Password, ResetPasswordForm as PasswordResetForm, ResetPasswordForm$1 as PasswordResetRequestForm, type NonErrorSession as Session, SessionContext, SessionProvider, SigningIn as SignInForm, SignOutButton, SigningUp as SignUpForm, SignedIn, SignedOut, SlackSignInButton as Slack, TenantSelector, UserInfo, XSignInButton as X, auth, getCsrfToken, getProviders, getSession, signIn, signOut, useEmailSignIn, useMe, useResetPassword, useSession, useSignIn, useSignUp, useTenantId, useTenants };
